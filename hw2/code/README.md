# 4.27

Write a multithreaded program that generates the Fibonacci sequence.

This program should work as follows: On the command line, the user will enter the number of Fibonacci numbers that the program is to generate. The program will then create a separate thread that will generate the Fibonacci numbers, placing the sequence in data that is shared by the threads (an array is probably the most convenient data structure). When the thread finishes execution, the parent thread will output the sequence generated by the child thread. Because the parent thread cannot begin outputting the Fibonacci sequence until the child thread finishes, the parent thread will have to wait for the child thread to finish.

### Compilation
```sh
make n=fibonacci
```

### Usage
```sh
./fibonacci.o <number>
```

### Example Output
```sh
$ ./fibonacci.o 10
0, 1, 1, 2, 3, 5, 8, 13, 21, 34,
```

![](./images/fibonacci.png)

# 4.24

Write a multithreaded version of this algorithm that creates a separate thread to generate a number of random points.

The thread will compute the number of points that fall within the circle and store that result in a global variable. When this thread has exited, the parent thread will calculate and output the estimated value of π. It is worth experimenting with the number of random points generated to see how accurate the estimation of π can be.

### Compilation

Make sure you have `openmp` installed.
```sh
make n=pi
```

### Usage
```sh
./pi.o <number of points>
```

### Example Output
```sh
$ ./pi.o 20000
Points in circle: 15707
Points in square: 20000
Pi: 3.141400
```

![](./images/pi.png)

# 6.33

Assume that a finite number of resources of a single resource type must be managed.

```c
#define MAX_RESOURCES 5

int available_resources = MAX_RESOURCES;
int decrease_count(int count) {
    if (available_resources < count)
        return -1;
    else {
        available_resources -= count;
        return 0;
    }
}

int increase_count(int count) {
    available_resources += count;
    return 0;
}
```

#### (a) Identify the data that needs to be protected from concurrent access.

The `available_resources` variable needs to be protected from concurrent access.

#### (b) Identify the location in the code where the race condition occurs.

`available_resources -= count;` and `available_resources += count;` are the locations where the race condition occurs.

#### (c) Write a multithreaded program using pthreads that allows multiple threads to access the increase and decrease functions concurrently.

### Compilation
```sh
make n=resources
```

### Usage
```sh
./resources.o 
```

### Example Output
```sh
$ ./resources.o
decrease: 2, available resources: 3
use: 2
decrease: 5, not enough resources: 3
decrease: 1, available resources: 2
use: 1
increase: 2, available resources: 4
decrease: 3, available resources: 1
use: 3
increase: 1, available resources: 2
decrease: 4, not enough resources: 2
increase: 3, available resources: 5
Available resources: 5
```

![](./images/resources.png)